{"ast":null,"code":"// ag-grid-enterprise v21.2.1\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar RangeController =\n/** @class */\nfunction () {\n  function RangeController() {\n    this.cellRanges = [];\n    this.bodyScrollListener = this.onBodyScroll.bind(this);\n    this.dragging = false;\n  }\n\n  RangeController.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n    this.autoScrollService = new AutoScrollService(this.gridPanel, this.gridOptionsWrapper);\n  };\n\n  RangeController.prototype.init = function () {\n    this.logger = this.loggerFactory.create('RangeController');\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.removeAllCellRanges.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.removeAllCellRanges.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.removeAllCellRanges.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_GROUP_OPENED, this.refreshLastRangeStart.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_MOVED, this.refreshLastRangeStart.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_PINNED, this.refreshLastRangeStart.bind(this));\n    this.eventService.addEventListener(ag_grid_community_1.Events.EVENT_COLUMN_VISIBLE, this.onColumnVisibleChange.bind(this));\n  };\n\n  RangeController.prototype.onColumnVisibleChange = function () {\n    var _this = this; // first move start column in last cell range (i.e. series chart range)\n\n\n    this.refreshLastRangeStart(); // then check if the column visibility has changed in any cell range\n\n    this.cellRanges.forEach(function (cellRange) {\n      var beforeCols = cellRange.columns; // remove hidden cols from cell range\n\n      cellRange.columns = cellRange.columns.filter(function (col) {\n        return col.isVisible();\n      });\n      var colsInRangeChanged = !ag_grid_community_1._.compareArrays(beforeCols, cellRange.columns);\n\n      if (colsInRangeChanged) {\n        // notify users and other parts of grid (i.e. status panel) that range has changed\n        _this.onRangeChanged({\n          started: false,\n          finished: true\n        }); // notify chart of cell range change\n\n\n        var event_1 = {\n          id: cellRange.id,\n          type: ag_grid_community_1.Events.EVENT_CHART_RANGE_SELECTION_CHANGED\n        };\n\n        _this.eventService.dispatchEvent(event_1);\n      }\n    });\n  };\n\n  RangeController.prototype.refreshLastRangeStart = function () {\n    var lastRange = ag_grid_community_1._.last(this.cellRanges);\n\n    if (!lastRange) {\n      return;\n    }\n\n    this.refreshRangeStart(lastRange);\n  };\n\n  RangeController.prototype.isContiguousRange = function (cellRange) {\n    var rangeColumns = cellRange.columns;\n\n    if (!rangeColumns.length) {\n      return false;\n    }\n\n    var allColumns = this.columnController.getAllDisplayedColumns();\n    var allPositions = [];\n    rangeColumns.forEach(function (col) {\n      return allPositions.push(allColumns.indexOf(col));\n    });\n    allPositions.sort(function (a, b) {\n      return a - b;\n    });\n    return ag_grid_community_1._.last(allPositions) - allPositions[0] + 1 === rangeColumns.length;\n  };\n\n  RangeController.prototype.getRangeStartRow = function (cellRange) {\n    if (cellRange.startRow && cellRange.endRow) {\n      var startRowIsFirst = this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow);\n      return startRowIsFirst ? cellRange.startRow : cellRange.endRow;\n    }\n\n    var pinned = this.pinnedRowModel.getPinnedTopRowCount() > 0 ? ag_grid_community_1.Constants.PINNED_TOP : undefined;\n    return {\n      rowIndex: 0,\n      rowPinned: pinned\n    };\n  };\n\n  RangeController.prototype.getRangeEndRow = function (cellRange) {\n    if (cellRange.startRow && cellRange.endRow) {\n      var startRowIsFirst = this.rowPositionUtils.before(cellRange.startRow, cellRange.endRow);\n      return startRowIsFirst ? cellRange.endRow : cellRange.startRow;\n    }\n\n    var pinnedBottomRowCount = this.pinnedRowModel.getPinnedBottomRowCount();\n    var pinnedBottom = pinnedBottomRowCount > 0;\n\n    if (pinnedBottom) {\n      return {\n        rowIndex: pinnedBottomRowCount - 1,\n        rowPinned: ag_grid_community_1.Constants.PINNED_BOTTOM\n      };\n    }\n\n    return {\n      rowIndex: this.rowModel.getRowCount() - 1,\n      rowPinned: undefined\n    };\n  };\n\n  RangeController.prototype.setRangeToCell = function (cell, appendRange) {\n    if (appendRange === void 0) {\n      appendRange = false;\n    }\n\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    var columns = this.calculateColumnsBetween(cell.column, cell.column);\n\n    if (!columns) {\n      return;\n    }\n\n    var suppressMultiRangeSelections = this.gridOptionsWrapper.isSuppressMultiRangeSelection(); // if not appending, then clear previous range selections\n\n    if (suppressMultiRangeSelections || !appendRange || ag_grid_community_1._.missing(this.cellRanges)) {\n      this.removeAllCellRanges(true);\n    }\n\n    var rowForCell = {\n      rowIndex: cell.rowIndex,\n      rowPinned: cell.rowPinned\n    }; // if there is already a range for this cell, then we reuse the same range, otherwise the user\n    // can ctrl & click a cell many times and hit ctrl+c, which would result in the cell getting copied\n    // many times to the clipboard.\n\n    var existingRange;\n\n    for (var i = 0; i < this.cellRanges.length; i++) {\n      var range = this.cellRanges[i];\n      var matches = // check cols are same\n      range.columns && range.columns.length === 1 && range.columns[0] === cell.column && // check rows are same\n      this.rowPositionUtils.sameRow(rowForCell, range.startRow) && this.rowPositionUtils.sameRow(rowForCell, range.endRow);\n\n      if (matches) {\n        existingRange = range;\n        break;\n      }\n    }\n\n    if (existingRange) {\n      // we need it at the end of the list, as the dragStart picks the last created\n      // range as the start point for the drag\n      var atEndOfList = ag_grid_community_1._.last(this.cellRanges) === existingRange;\n\n      if (!atEndOfList) {\n        ag_grid_community_1._.removeFromArray(this.cellRanges, existingRange);\n\n        this.cellRanges.push(existingRange);\n      }\n    } else {\n      var newRange = {\n        startRow: rowForCell,\n        endRow: rowForCell,\n        columns: columns,\n        startColumn: cell.column\n      };\n      this.cellRanges.push(newRange);\n    }\n\n    this.newestRangeStartCell = cell;\n    this.onDragStop();\n    this.onRangeChanged({\n      started: false,\n      finished: true\n    });\n  };\n\n  RangeController.prototype.extendLatestRangeToCell = function (cellPosition) {\n    if (this.isEmpty() || !this.newestRangeStartCell) {\n      return;\n    }\n\n    var cellRange = ag_grid_community_1._.last(this.cellRanges);\n\n    this.updateRangeEnd({\n      cellRange: cellRange,\n      cellPosition: cellPosition\n    });\n  };\n\n  RangeController.prototype.updateRangeEnd = function (params) {\n    var cellRange = params.cellRange,\n        cellPosition = params.cellPosition;\n    var beforeCols = cellRange.columns.slice();\n\n    var beforeEndRow = ag_grid_community_1._.cloneObject(cellRange.endRow);\n\n    var endColumn = cellPosition.column;\n    var colsToAdd = this.calculateColumnsBetween(cellRange.startColumn, endColumn);\n\n    if (!colsToAdd) {\n      return;\n    }\n\n    cellRange.columns = colsToAdd;\n    cellRange.endRow = {\n      rowIndex: cellPosition.rowIndex,\n      rowPinned: cellPosition.rowPinned\n    };\n    this.onRangeChanged({\n      started: false,\n      finished: true\n    });\n    var colsChanged = !ag_grid_community_1._.compareArrays(beforeCols, cellRange.columns);\n    var endRowChanged = JSON.stringify(beforeEndRow) !== JSON.stringify(cellRange.endRow);\n\n    if (colsChanged || endRowChanged) {\n      // Note that we are raising a new event as the Chart shouldn't be notified when other ranges are changed\n      // or when the chart setCellRanges when the chart gains focus!\n      var event_2 = {\n        id: cellRange.id,\n        type: ag_grid_community_1.Events.EVENT_CHART_RANGE_SELECTION_CHANGED\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n  };\n\n  RangeController.prototype.refreshRangeStart = function (cellRange) {\n    var startColumn = cellRange.startColumn,\n        columns = cellRange.columns;\n\n    var moveColInCellRange = function (colToMove, moveToFront) {\n      var otherCols = cellRange.columns.filter(function (col) {\n        return col !== colToMove;\n      });\n\n      if (colToMove) {\n        cellRange.startColumn = colToMove;\n        cellRange.columns = moveToFront ? [colToMove].concat(otherCols) : otherCols.concat([colToMove]);\n      } else {\n        cellRange.columns = otherCols;\n      }\n    };\n\n    var _a = this.getRangeEdgeColumns(cellRange),\n        left = _a.left,\n        right = _a.right;\n\n    var shouldMoveLeftCol = startColumn === columns[0] && startColumn !== left;\n\n    if (shouldMoveLeftCol) {\n      moveColInCellRange(left, true);\n      return;\n    }\n\n    var shouldMoveRightCol = startColumn === ag_grid_community_1._.last(columns) && startColumn === right;\n\n    if (shouldMoveRightCol) {\n      moveColInCellRange(right, false);\n      return;\n    }\n  };\n\n  RangeController.prototype.getRangeEdgeColumns = function (cellRange) {\n    var allColumns = this.columnController.getAllDisplayedColumns();\n    var allIndices = [];\n\n    for (var _i = 0, _a = cellRange.columns; _i < _a.length; _i++) {\n      var column = _a[_i];\n      var idx = allColumns.indexOf(column);\n\n      if (idx > -1) {\n        allIndices.push(idx);\n      }\n    }\n\n    allIndices.sort(function (a, b) {\n      return a - b;\n    });\n    return {\n      left: allColumns[allIndices[0]],\n      right: allColumns[ag_grid_community_1._.last(allIndices)]\n    };\n  }; // returns true if successful, false if not successful\n\n\n  RangeController.prototype.extendLatestRangeInDirection = function (key) {\n    if (this.isEmpty() || !this.newestRangeStartCell) {\n      return;\n    }\n\n    var lastRange = ag_grid_community_1._.last(this.cellRanges);\n\n    var startCell = this.newestRangeStartCell;\n    var firstCol = lastRange.columns[0];\n\n    var lastCol = ag_grid_community_1._.last(lastRange.columns); // find the cell that is at the furthest away corner from the starting cell\n\n\n    var endCellIndex = lastRange.endRow.rowIndex;\n    var endCellFloating = lastRange.endRow.rowPinned;\n    var endCellColumn = startCell.column === firstCol ? lastCol : firstCol;\n    var endCell = {\n      column: endCellColumn,\n      rowIndex: endCellIndex,\n      rowPinned: endCellFloating\n    };\n    var newEndCell = this.cellNavigationService.getNextCellToFocus(key, endCell); // if user is at end of grid, so no cell to extend to, we return false\n\n    if (!newEndCell) {\n      return;\n    }\n\n    this.setCellRange({\n      rowStartIndex: startCell.rowIndex,\n      rowStartPinned: startCell.rowPinned,\n      rowEndIndex: newEndCell.rowIndex,\n      rowEndPinned: newEndCell.rowPinned,\n      columnStart: startCell.column,\n      columnEnd: newEndCell.column\n    });\n    return newEndCell;\n  };\n\n  RangeController.prototype.setCellRange = function (params) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    this.removeAllCellRanges(true);\n    this.addCellRange(params);\n  };\n\n  RangeController.prototype.setCellRanges = function (cellRanges) {\n    var _this = this;\n\n    this.removeAllCellRanges(true);\n    cellRanges.forEach(function (newRange) {\n      if (newRange.columns && newRange.startRow) {\n        _this.newestRangeStartCell = {\n          rowIndex: newRange.startRow.rowIndex,\n          rowPinned: newRange.startRow.rowPinned,\n          column: newRange.columns[0]\n        };\n      }\n\n      _this.cellRanges.push(newRange);\n    });\n    this.onRangeChanged({\n      started: false,\n      finished: true\n    });\n  };\n\n  RangeController.prototype.createCellRangeFromCellRangeParams = function (params) {\n    var _this = this;\n\n    var columns;\n\n    if (params.columns) {\n      columns = [];\n      params.columns.forEach(function (key) {\n        var col = _this.columnController.getColumnWithValidation(key);\n\n        if (col) {\n          columns.push(col);\n        }\n      });\n    } else {\n      var columnStart = this.columnController.getColumnWithValidation(params.columnStart);\n      var columnEnd = this.columnController.getColumnWithValidation(params.columnEnd);\n\n      if (!columnStart || !columnEnd) {\n        return;\n      }\n\n      columns = this.calculateColumnsBetween(columnStart, columnEnd);\n    }\n\n    if (!columns) {\n      return;\n    }\n\n    var startRow = undefined;\n\n    if (params.rowStartIndex != null) {\n      startRow = {\n        rowIndex: params.rowStartIndex,\n        rowPinned: params.rowStartPinned\n      };\n    }\n\n    var endRow = undefined;\n\n    if (params.rowEndIndex != null) {\n      endRow = {\n        rowIndex: params.rowEndIndex,\n        rowPinned: params.rowEndPinned\n      };\n    }\n\n    var newRange = {\n      startRow: startRow,\n      endRow: endRow,\n      columns: columns,\n      startColumn: columns[0]\n    };\n    return newRange;\n  };\n\n  RangeController.prototype.addCellRange = function (params) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    var newRange = this.createCellRangeFromCellRangeParams(params);\n\n    if (newRange) {\n      this.cellRanges.push(newRange);\n      this.onRangeChanged({\n        started: false,\n        finished: true\n      });\n    }\n  };\n\n  RangeController.prototype.getCellRanges = function () {\n    return this.cellRanges;\n  };\n\n  RangeController.prototype.isEmpty = function () {\n    return this.cellRanges.length === 0;\n  };\n\n  RangeController.prototype.isMoreThanOneCell = function () {\n    if (this.cellRanges.length === 0) {\n      // no ranges, so not more than one cell\n      return false;\n    } else if (this.cellRanges.length > 1) {\n      // many ranges, so more than one cell\n      return true;\n    } // only one range, return true if range has more than one\n\n\n    var range = this.cellRanges[0];\n    var startRow = this.getRangeStartRow(range);\n    var endRow = this.getRangeEndRow(range);\n    var moreThanOneCell = startRow.rowPinned !== endRow.rowPinned || startRow.rowIndex !== endRow.rowIndex || range.columns.length !== 1;\n    return moreThanOneCell;\n  };\n\n  RangeController.prototype.removeAllCellRanges = function (silent) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    this.onDragStop();\n    this.cellRanges.length = 0;\n\n    if (!silent) {\n      this.onRangeChanged({\n        started: false,\n        finished: true\n      });\n    }\n  }; // as the user is dragging outside of the panel, the div starts to scroll, which in turn\n  // means we are selection more (or less) cells, but the mouse isn't moving, so we recalculate\n  // the selection my mimicking a new mouse event\n\n\n  RangeController.prototype.onBodyScroll = function () {\n    this.onDragging(this.lastMouseEvent);\n  };\n\n  RangeController.prototype.isCellInAnyRange = function (cell) {\n    return this.getCellRangeCount(cell) > 0;\n  };\n\n  RangeController.prototype.isCellInSpecificRange = function (cell, range) {\n    var columnInRange = range.columns !== null && range.columns.indexOf(cell.column) >= 0;\n    var rowInRange = this.isRowInRange(cell.rowIndex, cell.rowPinned, range);\n    return columnInRange && rowInRange;\n  }; // returns the number of ranges this cell is in\n\n\n  RangeController.prototype.getCellRangeCount = function (cell) {\n    var _this = this;\n\n    if (this.isEmpty()) {\n      return 0;\n    }\n\n    var matchingCount = 0;\n    this.cellRanges.forEach(function (cellRange) {\n      if (_this.isCellInSpecificRange(cell, cellRange)) {\n        matchingCount++;\n      }\n    });\n    return matchingCount;\n  };\n\n  RangeController.prototype.isRowInRange = function (rowIndex, floating, cellRange) {\n    var firstRow = this.getRangeStartRow(cellRange);\n    var lastRow = this.getRangeEndRow(cellRange);\n    var thisRow = {\n      rowIndex: rowIndex,\n      rowPinned: floating\n    }; // compare rowPinned with == instead of === because it can be `null` or `undefined`\n\n    var equalsFirstRow = thisRow.rowIndex === firstRow.rowIndex && thisRow.rowPinned == firstRow.rowPinned;\n    var equalsLastRow = thisRow.rowIndex === lastRow.rowIndex && thisRow.rowPinned == lastRow.rowPinned;\n\n    if (equalsFirstRow || equalsLastRow) {\n      return true;\n    }\n\n    var afterFirstRow = !this.rowPositionUtils.before(thisRow, firstRow);\n    var beforeLastRow = this.rowPositionUtils.before(thisRow, lastRow);\n    return afterFirstRow && beforeLastRow;\n  };\n\n  RangeController.prototype.getDraggingRange = function () {\n    return this.draggingRange;\n  };\n\n  RangeController.prototype.onDragStart = function (mouseEvent) {\n    if (!this.gridOptionsWrapper.isEnableRangeSelection()) {\n      return;\n    }\n\n    var ctrlKey = mouseEvent.ctrlKey,\n        metaKey = mouseEvent.metaKey,\n        shiftKey = mouseEvent.shiftKey; // ctrlKey for windows, metaKey for Apple\n\n    var multiKeyPressed = ctrlKey || metaKey;\n    var allowMulti = !this.gridOptionsWrapper.isSuppressMultiRangeSelection();\n    var multiSelectKeyPressed = allowMulti ? multiKeyPressed : false;\n    var mouseCell = this.mouseEventService.getCellPositionForEvent(mouseEvent);\n\n    if (ag_grid_community_1._.missing(mouseCell)) {\n      // if drag wasn't on cell, then do nothing, including do not set dragging=true,\n      // (which them means onDragging and onDragStop do nothing)\n      return;\n    }\n\n    if (!multiSelectKeyPressed && (!shiftKey || ag_grid_community_1._.exists(ag_grid_community_1._.last(this.cellRanges).type))) {\n      this.removeAllCellRanges(true);\n    }\n\n    this.dragging = true;\n    this.draggingCell = mouseCell;\n    this.lastMouseEvent = mouseEvent;\n\n    if (!shiftKey) {\n      this.newestRangeStartCell = mouseCell;\n    } // if we didn't clear the ranges, then dragging means the user clicked, and when the\n    // user clicks it means a range of one cell was created. we need to extend this range\n    // rather than creating another range. otherwise we end up with two distinct ranges\n    // from a drag operation (one from click, and one from drag).\n\n\n    if (this.cellRanges.length > 0) {\n      this.draggingRange = ag_grid_community_1._.last(this.cellRanges);\n    } else {\n      var mouseRowPosition = {\n        rowIndex: mouseCell.rowIndex,\n        rowPinned: mouseCell.rowPinned\n      };\n      this.draggingRange = {\n        startRow: mouseRowPosition,\n        endRow: mouseRowPosition,\n        columns: [mouseCell.column],\n        startColumn: this.newestRangeStartCell.column\n      };\n      this.cellRanges.push(this.draggingRange);\n    }\n\n    this.gridPanel.addScrollEventListener(this.bodyScrollListener);\n    this.onRangeChanged({\n      started: true,\n      finished: false\n    });\n  };\n\n  RangeController.prototype.onDragging = function (mouseEvent) {\n    if (!this.dragging || !mouseEvent) {\n      return;\n    }\n\n    this.lastMouseEvent = mouseEvent;\n    var cellPosition = this.mouseEventService.getCellPositionForEvent(mouseEvent);\n    var mouseAndStartInPinnedTop = cellPosition && cellPosition.rowPinned === 'top' && this.newestRangeStartCell.rowPinned === 'top';\n    var mouseAndStartInPinnedBottom = cellPosition && cellPosition.rowPinned === 'bottom' && this.newestRangeStartCell.rowPinned === 'bottom';\n    var skipVerticalScroll = mouseAndStartInPinnedTop || mouseAndStartInPinnedBottom;\n    this.autoScrollService.check(mouseEvent, skipVerticalScroll);\n\n    if (!cellPosition || !this.draggingCell || this.cellPositionUtils.equals(this.draggingCell, cellPosition)) {\n      return;\n    }\n\n    var columns = this.calculateColumnsBetween(this.newestRangeStartCell.column, cellPosition.column);\n\n    if (!columns) {\n      return;\n    }\n\n    this.draggingCell = cellPosition;\n    this.draggingRange.endRow = {\n      rowIndex: cellPosition.rowIndex,\n      rowPinned: cellPosition.rowPinned\n    };\n    this.draggingRange.columns = columns;\n    this.onRangeChanged({\n      started: false,\n      finished: false\n    });\n  };\n\n  RangeController.prototype.onDragStop = function () {\n    if (!this.dragging) {\n      return;\n    }\n\n    this.autoScrollService.ensureCleared();\n    this.gridPanel.removeScrollEventListener(this.bodyScrollListener);\n    this.lastMouseEvent = null;\n    this.dragging = false;\n    this.draggingRange = undefined;\n    this.draggingCell = undefined;\n    this.onRangeChanged({\n      started: false,\n      finished: true\n    });\n  };\n\n  RangeController.prototype.onRangeChanged = function (params) {\n    var started = params.started,\n        finished = params.finished;\n    this.dispatchChangedEvent(started, finished);\n  };\n\n  RangeController.prototype.dispatchChangedEvent = function (started, finished) {\n    var event = {\n      type: ag_grid_community_1.Events.EVENT_RANGE_SELECTION_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      started: started,\n      finished: finished\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  RangeController.prototype.calculateColumnsBetween = function (columnFrom, columnTo) {\n    var allColumns = this.columnController.getAllDisplayedColumns();\n    var isSameColumn = columnFrom === columnTo;\n    var fromIndex = allColumns.indexOf(columnFrom);\n    var toIndex = isSameColumn ? fromIndex : allColumns.indexOf(columnTo);\n\n    if (fromIndex < 0) {\n      console.warn('ag-Grid: column ' + columnFrom.getId() + ' is not visible');\n      return undefined;\n    }\n\n    if (toIndex < 0) {\n      console.warn('ag-Grid: column ' + columnTo.getId() + ' is not visible');\n      return undefined;\n    }\n\n    if (isSameColumn) {\n      return [columnFrom];\n    }\n\n    var firstIndex = Math.min(fromIndex, toIndex);\n    var lastIndex = firstIndex === fromIndex ? toIndex : fromIndex;\n    var columns = [];\n\n    for (var i = firstIndex; i <= lastIndex; i++) {\n      columns.push(allColumns[i]);\n    }\n\n    return columns;\n  };\n\n  __decorate([ag_grid_community_1.Autowired('loggerFactory'), __metadata(\"design:type\", ag_grid_community_1.LoggerFactory)], RangeController.prototype, \"loggerFactory\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowModel'), __metadata(\"design:type\", Object)], RangeController.prototype, \"rowModel\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('eventService'), __metadata(\"design:type\", ag_grid_community_1.EventService)], RangeController.prototype, \"eventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnController'), __metadata(\"design:type\", ag_grid_community_1.ColumnController)], RangeController.prototype, \"columnController\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('mouseEventService'), __metadata(\"design:type\", ag_grid_community_1.MouseEventService)], RangeController.prototype, \"mouseEventService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", ag_grid_community_1.GridOptionsWrapper)], RangeController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('columnApi'), __metadata(\"design:type\", ag_grid_community_1.ColumnApi)], RangeController.prototype, \"columnApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('gridApi'), __metadata(\"design:type\", ag_grid_community_1.GridApi)], RangeController.prototype, \"gridApi\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('cellNavigationService'), __metadata(\"design:type\", ag_grid_community_1.CellNavigationService)], RangeController.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired(\"pinnedRowModel\"), __metadata(\"design:type\", ag_grid_community_1.PinnedRowModel)], RangeController.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('rowPositionUtils'), __metadata(\"design:type\", ag_grid_community_1.RowPositionUtils)], RangeController.prototype, \"rowPositionUtils\", void 0);\n\n  __decorate([ag_grid_community_1.Autowired('cellPositionUtils'), __metadata(\"design:type\", ag_grid_community_1.CellPositionUtils)], RangeController.prototype, \"cellPositionUtils\", void 0);\n\n  __decorate([ag_grid_community_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], RangeController.prototype, \"init\", null);\n\n  RangeController = __decorate([ag_grid_community_1.Bean('rangeController')], RangeController);\n  return RangeController;\n}();\n\nexports.RangeController = RangeController;\n\nvar AutoScrollService =\n/** @class */\nfunction () {\n  function AutoScrollService(gridPanel, gridOptionsWrapper) {\n    this.tickingInterval = null;\n    this.gridPanel = gridPanel;\n    this.gridOptionsWrapper = gridOptionsWrapper;\n  }\n\n  AutoScrollService.prototype.check = function (mouseEvent, skipVerticalScroll) {\n    if (skipVerticalScroll === void 0) {\n      skipVerticalScroll = false;\n    }\n\n    var rect = this.gridPanel.getBodyClientRect();\n    skipVerticalScroll = skipVerticalScroll || this.gridOptionsWrapper.getDomLayout() !== ag_grid_community_1.Constants.DOM_LAYOUT_NORMAL; // we don't do ticking if grid is auto height unless we have a horizontal scroller\n\n    if (skipVerticalScroll && !this.gridPanel.isHorizontalScrollShowing()) {\n      return;\n    }\n\n    this.tickLeft = mouseEvent.clientX < rect.left + 20;\n    this.tickRight = mouseEvent.clientX > rect.right - 20;\n    this.tickUp = mouseEvent.clientY < rect.top + 20 && !skipVerticalScroll;\n    this.tickDown = mouseEvent.clientY > rect.bottom - 20 && !skipVerticalScroll;\n\n    if (this.tickLeft || this.tickRight || this.tickUp || this.tickDown) {\n      this.ensureTickingStarted();\n    } else {\n      this.ensureCleared();\n    }\n  };\n\n  AutoScrollService.prototype.ensureTickingStarted = function () {\n    if (this.tickingInterval === null) {\n      this.tickingInterval = window.setInterval(this.doTick.bind(this), 100);\n      this.tickCount = 0;\n    }\n  };\n\n  AutoScrollService.prototype.doTick = function () {\n    this.tickCount++;\n    var vScrollPosition = this.gridPanel.getVScrollPosition();\n    var hScrollPosition = this.gridPanel.getHScrollPosition();\n    var tickAmount;\n    tickAmount = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;\n\n    if (this.tickUp) {\n      this.gridPanel.setVerticalScrollPosition(vScrollPosition.top - tickAmount);\n    }\n\n    if (this.tickDown) {\n      this.gridPanel.setVerticalScrollPosition(vScrollPosition.top + tickAmount);\n    }\n\n    if (this.tickLeft) {\n      this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left - tickAmount);\n    }\n\n    if (this.tickRight) {\n      this.gridPanel.setHorizontalScrollPosition(hScrollPosition.left + tickAmount);\n    }\n  };\n\n  AutoScrollService.prototype.ensureCleared = function () {\n    if (this.tickingInterval) {\n      window.clearInterval(this.tickingInterval);\n      this.tickingInterval = null;\n    }\n  };\n\n  return AutoScrollService;\n}();","map":null,"metadata":{},"sourceType":"script"}